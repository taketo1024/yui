use std::hash::Hash;

use yui_core::{Ring, RingOps, IndexList};
use yui_lin_comb::{Gen, LinComb};
use yui_matrix::sparse::{SpMat, SpVec};

use crate::{DisplayForGrid, RModStr};

// Represents a free R-module generated by a finite set of elements in X. 
#[derive(Default)]
pub struct XModStr<X, R>
where 
    X: Gen,
    R: Ring, for<'x> &'x R: RingOps<R>
{
    gens: IndexList<X>,
    _tors: Vec<R> // empty
}

impl<X, R> XModStr<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    pub fn zero() -> Self { 
        Self::from_iter([])
    }

    pub fn gens(&self) -> &IndexList<X> { 
        &self.gens
    }

    pub fn gen(&self, i: usize) -> &X {
        &self.gens[i]
    }

    pub fn vectorize(&self, z: &LinComb<X, R>) -> SpVec<R> {
        let n = self.rank();
        SpVec::generate(n, |set| { 
            for (x, a) in z.iter() { 
                let i = self.gens.index_of(x).unwrap();
                set(i, a.clone());
            }
        })
    }

    pub fn as_chain(&self, v: &SpVec<R>) -> LinComb<X, R> {
        assert_eq!(v.dim(), self.rank());

        let elems = v.iter().map(|(i, a)| 
            (self.gen(i).clone(), a.clone())
        );
        LinComb::from_iter(elems)
    }

    pub fn make_matrix<Y, F>(&self, to: &XModStr<Y, R>, f: F) -> SpMat<R>
    where Y: Gen, F: Fn(&X) -> Vec<(Y, R)> {
        make_matrix(&self.gens, &to.gens, f)
    }
}

impl<X, R> FromIterator<X> for XModStr<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    fn from_iter<T: IntoIterator<Item = X>>(iter: T) -> Self {
        let gens = IndexList::from_iter(iter);
        Self { gens, _tors: vec![] }
    }
}

impl<X, R> RModStr for XModStr<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    type R = R;

    fn rank(&self) -> usize {
        self.gens.len()
    }

    fn tors(&self) -> &Vec<Self::R> {
        &self._tors // empty
    }
}

impl<X, R> DisplayForGrid for XModStr<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    fn display_for_grid(&self) -> String {
        self.math_symbol()
    }
}

pub fn make_matrix<X, Y, R, F>(from: &IndexList<X>, to: &IndexList<Y>, f: F) -> SpMat<R>
where 
    X: Hash + Eq, Y: Hash + Eq, 
    R: Ring, for<'x> &'x R: RingOps<R>,
    F: Fn(&X) -> Vec<(Y, R)> 
{
    let (m, n) = (to.len(), from.len());
    SpMat::generate((m, n), |set|
        for (j, x) in from.iter().enumerate() {
            let ys = f(x);
            for (y, a) in ys {
                let i = to.index_of(&y).unwrap();
                set(i, j, a);
            }
        }
    )
}

#[cfg(test)]
mod tests { 
    use yui_lin_comb::Free;

    use super::*;

    type X = Free<i32>;
    fn e(i: isize) -> X { 
        X::from(i as i32)
    }
    
    #[test]
    fn test() { 
        let s = XModStr::from_iter(vec![e(0), e(1), e(2)]);
        
        let x = LinComb::from(e(0));
        let y = LinComb::from(e(1));
        let z = LinComb::from(e(2));

        assert_eq!(s.vectorize(&x), SpVec::unit(3, 0));
        assert_eq!(s.vectorize(&(&x - &y * 2 + &z * 3)), SpVec::from(vec![1,-2,3]));
        
        let v = SpVec::from(vec![0, 2, -3]);
        assert_eq!(s.as_chain(&v), &y * 2 - &z * 3);
    }
}