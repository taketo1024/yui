use std::fmt::Display;

use yui::{EucRing, EucRingOps, IndexList, Ring, RingOps};
use yui::lc::{Gen, Lc};
use yui_matrix::sparse::{SpVec, Trans};

use crate::SummandTrait;

// Represents a free R-module generated by a finite set of elements in X. 

#[derive(Clone, Debug)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Summand<X, R>
where 
    X: Gen,
    R: Ring, for<'x> &'x R: RingOps<R>
{
    raw_gens: IndexList<X>,
    rank: usize, 
    tors: Vec<R>,
    trans: Trans<R>
}

impl<X, R> Summand<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    pub fn new(raw_gens: IndexList<X>, rank: usize, tors: Vec<R>, trans: Trans<R>) -> Self { 
        assert_eq!(trans.src_dim(), raw_gens.len());
        assert_eq!(trans.tgt_dim(), rank + tors.len());

        Self { raw_gens, rank, tors, trans }
    }

    pub fn from_raw_gens<Itr>(raw_gens: Itr) -> Self 
    where Itr: IntoIterator<Item = X> {
        let gens = raw_gens.into_iter().collect::<IndexList<X>>();
        let r = gens.len();
        Self::new(gens, r, vec![], Trans::id(r)) 
    }

    pub fn zero() -> Self { 
        Self::new(IndexList::new(), 0, vec![], Trans::zero())
    }

    pub fn raw_gens(&self) -> &IndexList<X> { 
        &self.raw_gens
    }

    pub fn trans(&self) -> &Trans<R> { 
        &self.trans
    }

    pub fn gen(&self, i: usize) -> Lc<X, R> { 
        let n = self.dim();
        let v = SpVec::unit(n, i);
        self.devectorize(&v)
    }

    pub fn vectorize(&self, z: &Lc<X, R>) -> SpVec<R> {
        let n = self.raw_gens.len();
        let v = SpVec::from_entries(n, z.iter().map(|(x, a)| { 
            let Some(i) = self.raw_gens.index_of(x) else { 
                panic!("{x} not found in generators: {:?}", &self.raw_gens);
            };
            (i, a.clone())
        }));

        self.trans.forward(&v)
    }

    pub fn vectorize_euc(&self, z: &Lc<X, R>) -> SpVec<R>
    where R: EucRing, for<'x> &'x R: EucRingOps<R> {
        let r = self.rank();
        let v = self.vectorize(z);

        SpVec::from_sorted_entries(v.dim(), v.iter().map(|(i, a)| { 
            if i < r { 
                (i, a.clone())
            } else { 
                let t = &self.tors()[i - r];
                (i, a % t)
            }
        }))
    }

    pub fn devectorize(&self, v: &SpVec<R>) -> Lc<X, R> {
        assert_eq!(v.dim(), self.dim());

        let v = self.trans.backward(v);

        Lc::from_iter( v.iter().map(|(i, a)| 
            (self.raw_gens[i].clone(), a.clone())
        ) )
    }

    pub fn merge<Y>(&mut self, other: Summand<Y, R>)
    where Y: Gen { 
        assert_eq!(self.trans.tgt_dim(), other.trans.src_dim());

        self.rank = other.rank;
        self.tors = other.tors.clone();
        self.trans.merge(other.trans);
        self.trans.reduce();
    }
}

impl<X, R> Default for Summand<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    fn default() -> Self {
        Self::zero()
    }
}

impl<X, R> Display for Summand<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.display().fmt(f)
    }
}

impl<X, R> SummandTrait for Summand<X, R>
where X: Gen, R: Ring, for<'x> &'x R: RingOps<R> {
    type R = R;

    fn rank(&self) -> usize {
        self.rank
    }

    fn tors(&self) -> &[R] {
        &self.tors
    }
}

#[cfg(test)]
mod tests { 
    use yui::lc::Free;

    use super::*;

    type X = Free<i32>;
    fn e(i: isize) -> X { 
        X::from(i as i32)
    }
    
    #[test]
    fn vectorize() { 
        let s = Summand::from_raw_gens([e(0), e(1), e(2)]);
        
        let x = Lc::from(e(0));
        let y = Lc::from(e(1));
        let z = Lc::from(e(2));

        let v = s.vectorize(&x);
        assert_eq!(v, SpVec::unit(3, 0));

        let v = s.vectorize(&(&x - &y * 2 + &z * 3));
        assert_eq!(v, SpVec::from(vec![1,-2,3]));
    }
        
    #[test]
    fn as_chain() { 
        let s = Summand::from_raw_gens([e(0), e(1), e(2)]);
        
        let x = Lc::from(e(0));
        let y = Lc::from(e(1));
        let z = Lc::from(e(2));

        let v = SpVec::from(vec![1, 2, -3]);
        let w = s.devectorize(&v);

        assert_eq!(w, &x + &y * 2 - &z * 3);
    }
}